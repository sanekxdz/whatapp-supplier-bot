import pkg from '@whiskeysockets/baileys';
import { makeWASocket, fetchLatestBaileysVersion, DisconnectReason, useMultiFileAuthState } from '@whiskeysockets/baileys';
import { readFileSync } from 'fs';
import { parseOrder } from './helpers/parseOrder.js';
import qrcode from 'qrcode-terminal';

const suppliers = JSON.parse(readFileSync('./db/suppliers.json', 'utf-8'));

const startSock = async () => {
  const { state, saveCreds } = await useMultiFileAuthState('./sessions');
  const { version } = await fetchLatestBaileysVersion();

  const sock = makeWASocket({
    version,
    auth: state
  });

  sock.ev.on('creds.update', saveCreds);

  sock.ev.on('connection.update', (update) => {
    const { connection, lastDisconnect, qr } = update;
    if (qr) {
      qrcode.generate(qr, { small: true });
    }
    if (connection === 'close') {
      const shouldReconnect = lastDisconnect?.error?.output?.statusCode !== DisconnectReason.loggedOut;
      if (shouldReconnect) startSock();
    }
  });

  const branchNames = {
    "Bookish Cafe": "Проспект Мангилик Ел, 35/1, Астана",
    "Book Cafe": "Улица Максут Нарикбаев, 22, Астана",
    "Famous Караоке": "Улица Шарль де Голль, 13, Астана"
  };
  const userBranchSelection = {};

  sock.ev.on('messages.upsert', async ({ messages, type }) => {
    if (!messages || messages.length === 0) return;

    const msg = messages[0];
    if (!msg.message || msg.key.fromMe) return;

    const sender = msg.key.remoteJid;
    const text = msg.message.conversation || msg.message.extendedTextMessage?.text;
    if (!text) return;

    if (!userBranchSelection[sender]) {
      const options = Object.keys(branchNames)
        .map((name, idx) => `📍 ${idx + 1}) ${name} — ${branchNames[name]}`)
        .join('\n');
      await sock.sendMessage(sender, { text: `🔸 *Выберите заведение для заказа:*
${options}` });
      userBranchSelection[sender] = { step: 'awaiting_branch' };
      return;
    }

    if (userBranchSelection[sender].step === 'awaiting_branch') {
      const choice = parseInt(text.trim());
      const branchList = Object.keys(branchNames);
      if (choice >= 1 && choice <= branchList.length) {
        const selected = branchList[choice - 1];
        userBranchSelection[sender] = {
          step: 'awaiting_date',
          name: selected,
          address: branchNames[selected]
        };
        await sock.sendMessage(sender, { text: '📅 Укажите, на какую дату требуется заказ (например: 22.04.2025):' });
      } else {
        await sock.sendMessage(sender, { text: '⚠️ Пожалуйста, введите номер от 1 до 3, чтобы выбрать филиал.' });
      }
      return;
    }

    if (userBranchSelection[sender].step === 'awaiting_date') {
      const datePattern = /^\d{2}\.\d{2}\.\d{4}$/;
      if (!datePattern.test(text.trim())) {
        await sock.sendMessage(sender, { text: '❗ Неверный формат даты. Пожалуйста, используйте формат: 22.04.2025' });
        return;
      }

      userBranchSelection[sender].date = text.trim();
      userBranchSelection[sender].step = 'awaiting_order';
      await sock.sendMessage(sender, { text: '✅ Отлично! Теперь, пожалуйста, отправьте ваш заказ в виде списка.' });
      return;
    }

    if (userBranchSelection[sender]?.step === 'awaiting_order' && text.toLowerCase().includes('мне нужно')) {
      await sock.sendMessage(sender, { text: '🛒 Ваш заказ принят и обрабатывается. Ожидайте подтверждение ✅' });
    }

    const order = parseOrder(text, suppliers);
    for (const [supplier, data] of Object.entries(order)) {
      if (data.items.length === 0) continue;

      const message = [
        `👋 Добрый день! Это заказ от *${userBranchSelection[sender].name}*`,
        `📅 На дату: ${userBranchSelection[sender].date}, адрес: ${userBranchSelection[sender].address}`,
        '',
        ...data.items.map(item => `▫️ ${item}`)
      ].join('\n');

      await sock.sendMessage(data.phone + '@s.whatsapp.net', { text: message });
      await sock.sendMessage(sender, { text: `📬 Отправлено ${supplier}:
${message}` });
    }
  });
};

startSock();
