import pkg from '@whiskeysockets/baileys';
import { makeWASocket, fetchLatestBaileysVersion, DisconnectReason, useMultiFileAuthState } from '@whiskeysockets/baileys';
import { readFileSync } from 'fs';
import { parseOrder } from './helpers/parseOrder.js';
import qrcode from 'qrcode-terminal';

const suppliers = JSON.parse(readFileSync('./db/suppliers.json', 'utf-8'));

const startSock = async () => {
  const { state, saveCreds } = await useMultiFileAuthState('./sessions');
  const { version } = await fetchLatestBaileysVersion();

  const sock = makeWASocket({
    version,
    auth: state
  });

  sock.ev.on('creds.update', saveCreds);

  sock.ev.on('connection.update', (update) => {
    const { connection, lastDisconnect, qr } = update;
    if (qr) {
      qrcode.generate(qr, { small: true });
    }
    if (connection === 'close') {
      const shouldReconnect = lastDisconnect?.error?.output?.statusCode !== DisconnectReason.loggedOut;
      if (shouldReconnect) startSock();
    }
  });

  const branchNames = {
    "Bookish Cafe": "ĞŸÑ€Ğ¾ÑĞ¿ĞµĞºÑ‚ ĞœĞ°Ğ½Ğ³Ğ¸Ğ»Ğ¸Ğº Ğ•Ğ», 35/1, ĞÑÑ‚Ğ°Ğ½Ğ°",
    "Book Cafe": "Ğ£Ğ»Ğ¸Ñ†Ğ° ĞœĞ°ĞºÑÑƒÑ‚ ĞĞ°Ñ€Ğ¸ĞºĞ±Ğ°ĞµĞ², 22, ĞÑÑ‚Ğ°Ğ½Ğ°",
    "Famous ĞšĞ°Ñ€Ğ°Ğ¾ĞºĞµ": "Ğ£Ğ»Ğ¸Ñ†Ğ° Ğ¨Ğ°Ñ€Ğ»ÑŒ Ğ´Ğµ Ğ“Ğ¾Ğ»Ğ»ÑŒ, 13, ĞÑÑ‚Ğ°Ğ½Ğ°"
  };
  const userBranchSelection = {};

  sock.ev.on('messages.upsert', async ({ messages, type }) => {
    if (!messages || messages.length === 0) return;

    const msg = messages[0];
    if (!msg.message || msg.key.fromMe) return;

    const sender = msg.key.remoteJid;
    const text = msg.message.conversation || msg.message.extendedTextMessage?.text;
    if (!text) return;

    if (!userBranchSelection[sender]) {
      const options = Object.keys(branchNames)
        .map((name, idx) => `ğŸ“ ${idx + 1}) ${name} â€” ${branchNames[name]}`)
        .join('\n');
      await sock.sendMessage(sender, { text: `ğŸ”¸ *Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ·Ğ°Ğ²ĞµĞ´ĞµĞ½Ğ¸Ğµ Ğ´Ğ»Ñ Ğ·Ğ°ĞºĞ°Ğ·Ğ°:*
${options}` });
      userBranchSelection[sender] = { step: 'awaiting_branch' };
      return;
    }

    if (userBranchSelection[sender].step === 'awaiting_branch') {
      const choice = parseInt(text.trim());
      const branchList = Object.keys(branchNames);
      if (choice >= 1 && choice <= branchList.length) {
        const selected = branchList[choice - 1];
        userBranchSelection[sender] = {
          step: 'awaiting_date',
          name: selected,
          address: branchNames[selected]
        };
        await sock.sendMessage(sender, { text: 'ğŸ“… Ğ£ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ, Ğ½Ğ° ĞºĞ°ĞºÑƒÑ Ğ´Ğ°Ñ‚Ñƒ Ñ‚Ñ€ĞµĞ±ÑƒĞµÑ‚ÑÑ Ğ·Ğ°ĞºĞ°Ğ· (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€: 22.04.2025):' });
      } else {
        await sock.sendMessage(sender, { text: 'âš ï¸ ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ²Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ½Ğ¾Ğ¼ĞµÑ€ Ğ¾Ñ‚ 1 Ğ´Ğ¾ 3, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ²Ñ‹Ğ±Ñ€Ğ°Ñ‚ÑŒ Ñ„Ğ¸Ğ»Ğ¸Ğ°Ğ».' });
      }
      return;
    }

    if (userBranchSelection[sender].step === 'awaiting_date') {
      const datePattern = /^\d{2}\.\d{2}\.\d{4}$/;
      if (!datePattern.test(text.trim())) {
        await sock.sendMessage(sender, { text: 'â— ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚ Ğ´Ğ°Ñ‚Ñ‹. ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚: 22.04.2025' });
        return;
      }

      userBranchSelection[sender].date = text.trim();
      userBranchSelection[sender].step = 'awaiting_order';
      await sock.sendMessage(sender, { text: 'âœ… ĞÑ‚Ğ»Ğ¸Ñ‡Ğ½Ğ¾! Ğ¢ĞµĞ¿ĞµÑ€ÑŒ, Ğ¿Ğ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ÑŒÑ‚Ğµ Ğ²Ğ°Ñˆ Ğ·Ğ°ĞºĞ°Ğ· Ğ² Ğ²Ğ¸Ğ´Ğµ ÑĞ¿Ğ¸ÑĞºĞ°.' });
      return;
    }

    if (userBranchSelection[sender]?.step === 'awaiting_order' && text.toLowerCase().includes('Ğ¼Ğ½Ğµ Ğ½ÑƒĞ¶Ğ½Ğ¾')) {
      await sock.sendMessage(sender, { text: 'ğŸ›’ Ğ’Ğ°Ñˆ Ğ·Ğ°ĞºĞ°Ğ· Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚ Ğ¸ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ°Ñ‚Ñ‹Ğ²Ğ°ĞµÑ‚ÑÑ. ĞĞ¶Ğ¸Ğ´Ğ°Ğ¹Ñ‚Ğµ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ âœ…' });
    }

    const order = parseOrder(text, suppliers);
    for (const [supplier, data] of Object.entries(order)) {
      if (data.items.length === 0) continue;

      const message = [
        `ğŸ‘‹ Ğ”Ğ¾Ğ±Ñ€Ñ‹Ğ¹ Ğ´ĞµĞ½ÑŒ! Ğ­Ñ‚Ğ¾ Ğ·Ğ°ĞºĞ°Ğ· Ğ¾Ñ‚ *${userBranchSelection[sender].name}*`,
        `ğŸ“… ĞĞ° Ğ´Ğ°Ñ‚Ñƒ: ${userBranchSelection[sender].date}, Ğ°Ğ´Ñ€ĞµÑ: ${userBranchSelection[sender].address}`,
        '',
        ...data.items.map(item => `â–«ï¸ ${item}`)
      ].join('\n');

      await sock.sendMessage(data.phone + '@s.whatsapp.net', { text: message });
      await sock.sendMessage(sender, { text: `ğŸ“¬ ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾ ${supplier}:
${message}` });
    }
  });
};

startSock();
